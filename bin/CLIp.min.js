/*
    Code maintained by Baconman321 (https://replit.com/@baconman321). If you want to use this then please provide appropriate credit.

*/

/*
  License (MIT):

  Copyright (2021) baconman321

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

const CLIp={};(()=>{"use strict";class e extends Error{constructor(e,...t){super(e,...t),this.name="RuntimeError",this.message="(CLIp runtime-evaluator): "+e}}class t extends Error{constructor(e,...t){super(e,...t),this.name="ParsetimeError",this.message="(CLIp parser): "+e}}class r extends Error{constructor(e,...t){super(e,...t),this.name="InitializationError",this.message="(CLIp Initializer): "+e}}class n extends Error{constructor(e,...t){super(e,...t),this.name="NameError",this.message="(CLIp name-checker): "+e}}let o=null;const a={executionMode:{value:"readWrite",allowedValues:["writeOnly","readOnly","readWrite"]},strictMode:!1,strictCommandMode:!1},i=["string","number","null","undefined","NaN","infer"];Object.freeze(a.allowedValues);const l={type:"_CLIpObjectletType",value:"_CLIpObjectletValue",propertyAccessibility:"_CLIpObjectletPropertyAccessibility",allowedValues:"_CLIpObjectletAllowedValues",allowedTypes:"_CLIPObjectletAllowedTypes",allowListeners:"_CLIpObjectletAllowListeners",listeners:"_CLIpListenersArray",setter:"_CLIpObjectletSetter",locked:"_CLIpCommandletLocked",sealed:"_CLIpCommanderSealed"};Object.freeze(l);const s=e=>e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&");function p(e,t){if(null===o)throw new r("Root object is not initiated.");if(t&&(e[l.locked]||e[l.sealed]))throw new r("Cannot mutate a locked commandlet/sealed commander.")}const c=e=>{if(void 0===e)throw new TypeError('Parameter "propertyName" (argument 1) is not defined.');if("string"!=typeof e)throw new TypeError(`Parameter "propertyName" (argument 1) is not of type "string". Expected string found "${e}" with type "${typeof e}".`);const t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_".split("");e=(e=>{try{e=e.toString()}catch(e){throw new TypeError("The argument passed in is not a valid string and cannot be converted to a string type.")}return[...e]})(e);let r=!1;return e.forEach(e=>{t.filter(t=>t===e).length<1&&(r=!0)}),!r};class u{constructor(){this.T_ESCAPE,this.T_STRING,this.T_POINTERSTART,this.T_POINTEREND,this.T_SETTERSTART,this.T_SETTEREND,this.T_ARGUMENTSEPARATOR,this.T_TYPEDECLSTART,this.T_TYPEDECLEND,this.T_LEGALCHARS="",this.IS_SETTER,this.SETTER_FOUND,this.POINTER_FOUND,this.IS_POINTER,this.IS_STRING,this.LAST_OPERATOR,this.IS_ESCAPE=!1,this.TYPE_DECL_OPEN=!1,this.COL=0,this.INPUT=""}InitializeTokens(e,t,r,n,o,a,i,l,s,p){if(arguments.length<10)throw new TypeError(`Failed to execute "InitializeTokens", 10 arguments are required but only ${arguments.length} present.`);let c=0;for(let e in arguments)if(++c,"string"!=typeof arguments[e])throw new TypeError(`Argument number ${c} is not of string type.`);this.T_ESCAPE=e,this.T_STRING=t,this.T_POINTERSTART=r,this.T_POINTEREND=n,this.T_SETTERSTART=o,this.T_SETTEREND=a,this.T_ARGUMENTSEPARATOR=i,this.T_TYPEDECLSTART=l,this.T_TYPEDECLEND=s,this.T_LEGALCHARS=p}Parse(e,t=!1,r=!1){if(arguments.length<1)throw new TypeError('Failed to execute "Parse", 1 argument required but only 0 present.');if("string"!=typeof e)throw new TypeError("Argument 1 passed in is not of string type.");const{T_ESCAPE:n,T_STRING:o,T_POINTERSTART:a,T_POINTEREND:i,T_SETTERSTART:l,T_SETTEREND:s,T_ARGUMENTSEPARATOR:p,T_LEGALCHARS:c,T_TYPEDECLSTART:u,T_TYPEDECLEND:y}=this;let{IS_SETTER:d,SETTER_FOUND:m,POINTER_FOUND:f,IS_POINTER:h,IS_STRING:w,LAST_OPERATOR:b,IS_ESCAPE:g,COL:v,TYPE_DECL_OPEN:E}=this;const j=new Array(0),C=new Array(0),T=new Array(0),_=new Array(0);let P=0,O=0,L=0,A=0,S=0,I=!1;r||(I=!0);const N=()=>{I&&O>0?j.push({type:"objectlet",column_numbers:[O,L],value:T.splice(0).join("")}):T.splice(0),O=0,L=0};for(let r=0;r<e.length;++r){++v;const x=e[r];if(S>0&&(I=!0),b=void 0===e[r-1]?"":e[r-1],g)I&&j.push({type:"escaped_char",column_numbers:[v-1,v],value:`\\${x}`}),g=!1;else if(x!==n||g||w)if(x!==o||w||E)if(x===o&&w&&!E){const e=C.splice(0);I&&j.push({type:"string",column_numbers:[P,v],value:e.join("")}),w=!1}else{if(w){C.push(x);continue}if(x!==a||h||E){if(x===i&&h&&b===a){I&&j.push({type:"pointer",column_numbers:[v-1,v],value:a+i}),f=!0,h=!1;continue}if(x!==l||d){if(x===s&&d&&b===l){if(I&&j.push({type:"setter",column_numbers:[v-1,v],value:l+s}),d=!1,m=!0,++S,t)break;continue}if(x!==p||d||h){if(x!==u||w||d||h){if(x!==y||w||d||h){if(E){_.push(x);continue}if(x===o&&!w&&E){w=!0;continue}if(x===o&&w&&E){w=!1,_.push(C.splice(0).join(""));continue}if(w&&E){C.push(x);continue}if(E){_.push(x);continue}if(c.split("").filter(e=>e===x).length>0&&!h&&!d&&!E){0===O&&T.length<1&&(O=v),T.push(x);continue}if(d){d=!1,L=v-1,N(),I&&j.push({type:"unknown_token",column_numbers:[v-1,v],value:e[r-1]+x});continue}if(h){h=!1,L=v-1,N(),I&&j.push({type:"unknown_token",column_numbers:[v-1,v],value:e[r-1]+x});continue}L=v-1,N(),I&&j.push({type:"unknown_token",column_numbers:[v,v],value:x});continue}E?(E=!1,j.push({type:"type_declarator",column_numbers:[A,v],value:`${u}${_.splice(0).join("")}${y}`}),A=0):j.push({type:"close_type_decl_failure",column_numbers:[v,v],value:x});continue}L=v-1,N(),E?j.push({type:"open_type_decl_failure",column_numbers:[v,v],value:x}):(E=!0,A=v);continue}L=v-1,N(),I&&j.push({type:"argument_separator",column_numbers:[v,v],value:p});continue}L=v-1,N(),m=!1,d=!0;continue}L=v-1,N(),f=!1,h=!0}else L=v-1,N(),w=!0,P=v;else g=!0,N()}return h?j.push({type:"unknown_token",column_numbers:[v,v],value:e[e.length-1]}):d&&j.push({type:"unknown_token",column_numbers:[v,v],value:e[e.length-1]}),T.length>0&&(L=v,N()),w?j.push({type:"unclosed_string",column_numbers:[P,v],value:C.join("")}):E&&j.push({type:"unclosed_type_declarator",column_numbers:[A,v],value:_.join("")}),j}}CLIp.InitRoot=(()=>{if(null!==o)throw new r("Root cannot be initiated twice!");o=new Object,Object.defineProperty(o,"CLIp",{value:{},enumerable:!0}),Object.defineProperty(o.CLIp,l.type,{value:"clip-help",enumerable:!0});const e=o.CLIp;Object.defineProperty(e,"About",{value:{[l.type]:"property",[l.allowedValues]:new Array(0),[l.propertyAccessibility]:"read-only",[l.allowListeners]:!1,[l.listeners]:new Array(0),[l.value]:'CLIp (Stands for "CLI parser", pronounced "Clype") is a command line interpreter that is programmed in JavaScript. It allows functionality for creating a terminal-like interface for applications (especially online games). CLIp is built and maintained by Baconman321, so check him out (https://replit.com/@baconman321)! If you want a tutorial on how to use CLIp just execute the command "CLIp::OpenTutorial->null".'},enumerable:!0}),Object.defineProperty(o.CLIp,"OpenTutorial",{value:{[l.type]:"method",[l.allowListeners]:!1,[l.listeners]:new Array(0),[l.value]:()=>{"open"in globalThis&&globalThis.open("https://clip.baconman321.repl.co/docs/usertutorial")}},enumerable:!0}),Object.defineProperty(o.CLIp,"StrictModeEnabled",{value:{[l.type]:"method",[l.allowListeners]:!1,[l.listeners]:new Array(0),[l.value]:()=>a.strictMode},enumerable:!0}),Object.defineProperty(o.CLIp,"StrictCommandModeEnabled",{value:{[l.type]:"method",[l.allowListeners]:!1,[l.listeners]:new Array(0),[l.value]:()=>a.strictCommandMode},enumerable:!0}),Object.defineProperty(o.CLIp,"ExecutionMode",{value:{[l.type]:"method",[l.allowListeners]:!1,[l.listeners]:new Array(0),[l.value]:()=>a.executionMode.value},enumerable:!0}),Object.defineProperty(o.CLIp,"VERSION",{value:{[l.type]:"property",[l.allowedValues]:new Array(0),[l.allowedTypes]:new Array(0),[l.propertyAccessibility]:"read-only",[l.allowListeners]:!1,[l.listeners]:new Array(0),[l.value]:"1.0.0"},enumerable:!0});return(e=>{const t=e=>{const r=()=>{Object.freeze(e)};for(let n in e)Object.prototype.toString.call(e[n])===Object.prototype.toString.call(new Object)?(r(),t(e[n])):r()};t(e),Object.freeze(e)})(o.CLIp),o}),CLIp.ChangeExecutionMode=(e=>{if(a.executionMode.allowedValues.filter(t=>t===e).length<1)throw new r('Unrecognized execution mode "'+e+'". Accepted types are: '+a.executionMode.allowedValues);return a.executionMode.value=e,a.executionMode.value}),CLIp.EnableStrictMode=(()=>{p(),a.strictMode=!0}),CLIp.DisableStrictMode=(()=>{p(),a.strictMode=!1}),CLIp.EnableStrictCommandMode=(()=>{p(),a.strictCommandMode=!0}),CLIp.DisableStrictCommandMode=(()=>{p(),a.strictCommandMode=!1}),CLIp.DefineMainObject=((e,t)=>{if(p(e,!0),void 0===e)throw new TypeError('Parameter "mainObject" (argument 1) is not defined.');if("string"!=typeof e)throw new TypeError('Parameter "mainObject" (argument 1) must be a string containing the name of the main object.');if(void 0!==t&&typeof t!=typeof!0)throw new TypeError('Parameter "reConfigurable" (argument 2) is set but not of type "boolean".');for(let t in l)if(l[t]===e)throw new n("Naming collision with metadata of objectlets.");if(!c(e)){if(a.strictMode)throw new n('Main object name "'+e+'" has an illegal character. Legal characters are lower-case and upper-case alphabet letters and numbers.');console.warn('(CLIp name-checker): Main object name "'+e+'" has an illegal character (this will mess with user accessibility). Legal characters are lower-case and upper-case alphabet letters and numbers.')}if(void 0===t&&(t=!1),o[e])try{Object.defineProperty(o,e,{value:{[l.type]:"main-object"},enumerable:!0,configurable:!0})}catch(e){if(a.strictMode)throw new TypeError("Attempted to re-define a main property container that is not configured to do so.")}else Object.defineProperty(o,e,{value:{[l.type]:"main-object"},enumerable:!0,configurable:t});return o[e]}),CLIp.BindPropertyContainer=((e,t,r)=>{if(void 0===e)throw new TypeError('Paramter "object" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "objectName" (argument 2) is not defined.');if(typeof e!=typeof{})throw new TypeError('Parameter "object" (argument 1) is not a valid object.');if("string"!=typeof t)throw new TypeError('Parameter "objectName" (argument 2) is not of type "string".');if(void 0!==r&&typeof r!=typeof!0)throw new TypeError('Parameter "reConfigurable" (argument 3) is set but not of type "boolean".');for(let e in l)if(l[e]===t)throw new n("Naming collision with metadata of objectlets.");if(!c(t)){if(a.strictMode)throw new n('Property container name "'+t+'" has an illegal character. Legal characters are lower-case and upper-case alphabet letters and numbers.');console.warn('(CLIp name-checker): Property container name "'+t+'" has an illegal character (this will mess with user accessibility). Legal characters are lower-case and upper-case alphabet letters and numbers.')}if(void 0===r&&(r=!1),e[t])try{Object.defineProperty(e,t,{value:{[l.type]:"property-container"},enumerable:!0,configurable:!0})}catch(e){if(a.strictMode)throw new TypeError("Attempted to re-define a property container that is not configured to do so.")}else Object.defineProperty(e,t,{value:{[l.type]:"property-container"},enumerable:!0,configurable:r});return e[t]}),CLIp.BindProperty=((e,t,r,o)=>{if(p(e,!0),void 0===e)throw new TypeError('Paramter "propertyContainer" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "propertyArray" (argument 2) is not defined.');if(Object.prototype.toString.call(e)!==Object.prototype.toString.call(new Object))throw new TypeError('Parameter "propertyContainer (argument 2) is not an object to bind the property to.');if(Object.prototype.toString.call(t)!==Object.prototype.toString.call([]))throw new TypeError('Paramter "propertyArray" (argument 2) is not a valid array with values containing the name of the property of type "string" and the value.');if("string"!=typeof t[0])throw new TypeError('Paramter "propertyArray" (argument 2) is not a valid array with values containing the name of the property of type "string" and the value.');if(Object.prototype.toString.call(t[1])===Object.prototype.toString.call(new Object))throw new TypeError('The value cannot be an object. Try using "CLIp.BindPropertyContainer()" instead.');if(void 0!==t[2]&&"string"!=typeof t[2])throw new TypeError('Parameter "propertyArray" (argument 2) has the property-access value passed in but is not of type "string" representing the values "read-only" or "read-write".');if(void 0!==r&&typeof r!=typeof!0)throw new TypeError('Parameter "listenersAllowed" (arugment 3) is set but not of type "boolean".');if("read-only"!==t[2]&&"read-write"!==t[2]&&void 0!==t[2])throw new TypeError('Parameter "propertyArray" (argument 2) has the property-access value passed in but is not a string containing the values "read-only" or "read-write". Instead found a value of type "'+typeof t[2]+'" and a value of '+t[2]+".");if(void 0!==o&&typeof o!=typeof!0)throw new TypeError('Parameter "reConfigurable" (argument 4) is set but not of type "boolean".');for(let e in l)if(l[e]===t[0])throw new n("Naming collision with metadata of objectlets.");if(void 0===t[2]&&(t[2]="read-write"),!c(t[0])){if(a.strictMode)throw new n('Property name "'+t[0]+'" has an illegal character. Legal characters are lower-case and upper-case alphabet letters and numbers.');console.warn('(CLIp name-checker): Property name "'+t[0]+'" has an illegal character (this will mess with user accessibility). Legal characters are lower-case and upper-case alphabet letters and numbers.')}if(void 0===o&&(o=!1),e[t[0]])try{r?(Object.defineProperty(e,t[0].toString(),{value:{[l.type]:"property",[l.value]:t[1],[l.allowedValues]:new Array(0),[l.allowedTypes]:new Array(0),[l.propertyAccessibility]:t[2],[l.allowListeners]:!0,[l.listeners]:[]},enumerable:!0,configurable:o}),Object.defineProperty(e[t[0]],l.setter,{configurable:!0,enumerable:!0,set:function(e){const t=this[l.value];let r;try{this[l.value]=e}catch(e){r=e}r?this[l.listeners].forEach(r=>{r(this[l.type],e,t,error)}):this[l.listeners].forEach(r=>{r(this[l.type],e,t)})}})):Object.defineProperty(e,t[0].toString(),{value:{[l.type]:"property",[l.value]:t[1],[l.allowedValues]:new Array(0),[l.allowedTypes]:new Array(0),[l.propertyAccessibility]:t[2],[l.allowListeners]:!1},enumerable:!0,configurable:o})}catch(e){if(a.strictMode)throw new TypeError("Attempted to re-define a property that is not configured to do so.")}else r?(Object.defineProperty(e,t[0].toString(),{value:{[l.type]:"property",[l.value]:t[1],[l.allowedValues]:new Array(0),[l.allowedTypes]:new Array(0),[l.propertyAccessibility]:t[2],[l.allowListeners]:!0,[l.listeners]:[]},enumerable:!0,configurable:o}),Object.defineProperty(e[t[0]],l.setter,{configurable:!0,enumerable:!0,set:function(e){const t=this[l.value];let r;try{this[l.value]=e}catch(e){r=e}r?this[l.listeners].forEach(r=>{r(this[l.type],e,t,error)}):this[l.listeners].forEach(r=>{r(this[l.type],e,t)})}})):Object.defineProperty(e,t[0].toString(),{value:{[l.type]:"property",[l.value]:t[1],[l.allowedValues]:new Array(0),[l.allowedTypes]:new Array(0),[l.propertyAccessibility]:t[2],[l.allowListeners]:!1},enumerable:!0,configurable:o});return e[t[0]]}),CLIp.BindMethod=((e,t,r,o)=>{if(p(e,!0),void 0===e)throw new TypeError('Paramter "propertyContainer" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "methodArray" (argument 2) is not defined.');if(Object.prototype.toString.call(e)!==Object.prototype.toString.call(Object()))throw new TypeError('Parameter "propertyContainer" (argument 2) is not an objectlet to bind the property to.');if("string"!=typeof t[0])throw new TypeError('Paramter "methodArray" (argument 2) is not a valid array with values containing the name of the method of type "string" and the method of type "function".');if("function"!=typeof t[1])throw new TypeError('Paramter "methodArray" (argument 2) is not a valid array with values containing the name of the method of type "string" and the method of type "function".');if("string"!=typeof t[0])throw new TypeError('Paramter "propertyArray" (argument 2) is not a valid array with values containing the name of the property of type "string" and the value.');if(typeof t[1]==typeof{})throw new TypeError('The value cannot be an object. Try using "CLIp.BindPropertyContainer()" instead.');if(void 0!==r&&typeof r!=typeof!0)throw new TypeError('Parameter "listenersAllowed" (arugment 3) is set but not of type "boolean".');for(let e in l)if(l[e]===t[0])throw new n("Naming collision with metadata of objectlets.");if(void 0!==o&&typeof o!=typeof!0)throw new TypeError('Parameter "reConfigurable" (argument 4) is set but not of type "boolean".');if(!c(t[0])){if(a.strictMode)throw new n('Method name "'+t[0]+'" has an illegal character. Legal characters are lower-case and upper-case alphabet letters and numbers.');console.warn('(CLIp name-checker): Method name "'+t[0]+'" has an illegal character (this will mess with user accessibility). Legal characters are lower-case and upper-case alphabet letters and numbers.')}if(void 0===o&&(o=!1),e[t[0]])try{r?(Object.defineProperty(e,t[0].toString(),{value:{[l.type]:"method",[l.allowListeners]:!0,[l.listeners]:[],[l.value]:t[1]},enumerable:!0,configurable:o}),Object.defineProperty(e[t[0]],l.setter,{enumerable:!0,configurable:!0,set:function(e){const t=e[0];this[l.listeners].forEach(t=>{t(this[l.type],e)});const r=this[l.value](t);e[1]=r}})):Object.defineProperty(e,t[0].toString(),{value:{[l.type]:"method",[l.allowListeners]:!1,[l.value]:t[1]},enumerable:!0,configurable:o})}catch(e){if(a.strictMode)throw new TypeError("Attempted to re-define a method that is not configured to do so.")}else r?(Object.defineProperty(e,t[0].toString(),{value:{[l.type]:"method",[l.allowListeners]:!0,[l.listeners]:[],[l.value]:t[1]},enumerable:!0,configurable:o}),Object.defineProperty(e[t[0]],l.setter,{enumerable:!0,configurable:!0,set:function(e){const t=e[0];this[l.listeners].forEach(e=>{e(this[l.type],t)});const r=this[l.value](t);e[1]=r}})):Object.defineProperty(e,t[0].toString(),{value:{[l.type]:"method",[l.allowListeners]:!1,[l.value]:t[1]},enumerable:!0,configurable:o});return e[t[0]]}),CLIp.ChangeObjectletAccessibility=((e,t)=>{if(p(e,!0),typeof e!=typeof new Object&&!e[l.type])throw new TypeError('Parameter "objectlet" (argument 1) is not an object and/or is not a valid objectlet.');if("read-only"!==t&&"read-write"!==t)throw new r('Parameter "accessibility" (argument 2) is not a string with either the value "read-only" or read-write"');if(!e[l.propertyAccessibility])throw new r('Parameter "objectlet" (argument 1) is not set with a property accessibility mode.');e[l.propertyAccessibility]=t}),CLIp.LockCommandlet=(e=>{if(p(),typeof e!=typeof new Object||!e[l.type])throw new TypeError('Parameter "commandlet" (argument 1) is not an object and/or is not a valid commandlet.');if("main-object"===e[l.type]||"property-container"===e[l.type]||"clip-help"===e[l.type])throw new r("Cannot perform CLIp.LockCommandlet on a property container/main property container. Use CLIp.SealCommander instead.");return e[l.locked]?e:(e[l.locked]=!0,Object.freeze(e),e)}),CLIp.SealCommander=(e=>{if(typeof e!=typeof new Object||!e[l.type])throw new TypeError('Parameter "commandlet" (argument 1) is not an object and/or is not a valid commandlet.');if("main-object"!==e[l.type]&&"property-container"!==e[l.type]&&"clip-help"!==e[l.type])throw new r("Cannot perform CLIp.SealCommander on a commandlet. Use CLIp.LockCommandlet instead.");return e[l.sealed]?e:(e[l.sealed]=!0,Object.freeze(e),e)}),CLIp.BindRestrictingValues=((e,t)=>{p(t,!0);const n=e=>{throw new r(`Parameter "values" (argument 1) contains an invalid value that is not an array or is an empty array at the ${e}th index. The value should be an array containing a single allowed value and an array containing the allowed types for that value.`)},o=i.reduce((e,t)=>e+`, ${t}`);if(!Array.isArray(e))throw new TypeError('Parameter "values" (argument 1) is not a valid array containing the allowed values and an array of their their types.');if(Object.prototype.toString.call(t)!==Object.prototype.toString.call(new Object))throw new TypeError('Parameter "objectlet" (argument 2) is not a valid object representing the objectlet to bind restrictive values to.');if(!t[l.allowedValues])throw new r("Objectlet does not provide access to an allowed values object rendering it not applicable for allowed values.");if("read-only"===t[l.propertyAccessibility])throw new r("Objectlet is read-only invalidating the ability to bind restricting values on.");if(e.forEach((e,t)=>{Array.isArray(e)||n(t),e[0]||n(t),e[1]||n(t),Array.isArray(e[1])&&e[1].length||n(t),e[1].forEach(e=>{if(i.filter(t=>t===e).length<1&&"all"!==e[1])throw new TypeError(`Invalid data type "${e[0]}". Allowed data types are: ${o} as well as "all".`)})}),!t[l.allowedValues])throw new r('Parameter "objectlet" (argument 2) is not a valid objectlet and/or is not capable of binding restricting values to.');t[l.allowedValues]=e}),CLIp.BindRestrictingTypes=((e,t)=>{p(t,!0);const n=i.reduce((e,t)=>e+`, ${t}`);if(!Array.isArray(e))throw new TypeError('Parameter "types" (argument 1) is not a valid array containing the allowed types and an optional object with a key of "default_type" and a value of the default type to convert to.');if(Object.prototype.toString.call(t)!==Object.prototype.toString.call(new Object))throw new TypeError('Parameter "objectlet" (argument 2) is not a valid object representing the objectlet to bind restrictive types to.');if(!t[l.allowedTypes])throw new r("Objectlet does not provide access to an allowed types object rendering it not applicable for allowed types.");if("read-only"===t[l.propertyAccessibility])throw new r("Objectlet is read-only invalidating the ability to bind restricting types on.");if(!e.length)throw new r("The types array must include one valid type.");e.forEach(e=>{if(typeof e==typeof new Object){if(void 0===e.default_type)throw new TypeError('Parameter "types" (argument 1) contains an object that doesn\'t have a key named "default_value". If an object is present it should have a key name of "default_type" and contain the default type to convert to.');if(i.filter(t=>t===e.default_type).length<1&&"all"!==e.default_type)throw new TypeError(`Invalid data type "${e.default_type}". Allowed data types are: ${n} as well as "all".`)}else if(i.filter(t=>t===e).length<1&&"all"!==e)throw new TypeError(`Invalid data type "${e}". Allowed data types are: ${n} as well as "all".`)}),t[l.allowedTypes]=e}),CLIp.ChangeObjectletValue=((e,t,r=!1)=>{if(typeof!0!=typeof r)throw new TypeError('Parameter "triggerListeners" (argument 3) is set but not of type "boolean".');if(typeof new Object==typeof e[l.type]||"property"!==e[l.type]&&"method"!==e[l.type])throw new TypeError('Parameter "objectlet" (argument 1) is not a valid objectlet or is a commander.');if(e[l.locked])return[!1,"locked"];if("property"===e[l.type])return typeof Function==typeof Object.getOwnPropertyDescriptor(e,l.setter)&&r?(e[l.setter]=t,[!0,t]):(e[l.value]=t,[!0,t]);if(Function===typeof Object.getOwnPropertyDescriptor(e,l.setter)&&r){const r=[t];return e[l.setter]=r,[!0,r[1]]}return[!0,e[l.value](t)]}),CLIp.ReturnRoot=(()=>(p(),o)),CLIp.GetFromPath=(async e=>{if(void 0===e)throw new TypeError('Parameter "statement" (argument 1) is not of type "string".');const t=[];let r=!1,n=!1;const i=new u;i.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_");const l=i.Parse(e,!0);await CLIp.CheckCommandLegality(e).catch(e=>{r=!0}),l.forEach(e=>{"objectlet"===e.type?t.push(e.value):"string"===e.type&&(r=!0)});let s=o;return t.forEach((e,r)=>{if(!1===a.strictCommandMode)for(let n in s)n.toLowerCase()===e.toLowerCase()&&(t[r]=n);void 0!==s[t[r]]?(s=s[t[r]],n=!0):n=!1}),!(r||!n)&&s}),CLIp.ReturnMetadata=(e=>{if(p(),void 0===e)throw new TypeError('Parameter "objectlet" (argument 1) is not defined.');if(!e[l.type])throw new TypeError('Parameter "objectlet" (argument 1) is not a valid objectlet.');const t={},r=[],n=[];for(let t in l)n.push(t),r.push(e[l[t]]);return r.forEach((e,r)=>{void 0!==e&&(t[n[r]]=e)}),t}),CLIp.BindListener=((e,t,n)=>{if(p(e,!0),void 0===e)throw new TypeError('Parameter "objectlet" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "callback" (argument 2) is not defined.');if(Object.prototype.toString.call(e)!==Object.prototype.toString.call(new Object))throw new TypeError('Parameter "objectlet" (argument 1) is not a valid objectlet.');if("function"!=typeof t)throw new TypeError('Parameter "callback" (argument 2) is not a valid function.');if("property-container"===e[l.type]||"main-object"===e[l.type])throw new r('Cannot add a listener to an objectlet with a type "property-container" or "main-object".');if("property"!==e[l.type]&&"method"!==e[l.type])throw new r("Cannot add a listener to an objectlet without a valid or non-existing type.");if(void 0!==n&&typeof n!=typeof!0)throw new r('Parameter "replaceSameListenerHandler" (argument 3) is set but not of type "boolean".');if(!0!==e[l.allowListeners]&&!0===a.strictMode)throw new r("Cannot add a listener to an objectlet not explicitly configured to do so in strict mode.");if("read-only"===e[l.propertyAccessibility]&&a.strictMode)throw new r('Cannot add a listener to an objectlet with a property accessibility of "read-only" in strict mode.');void 0===e[l.listeners]&&Object.defineProperty(e,l.listeners,{value:[],enumerable:!0});let o=!1;if(e[l.listeners].forEach(e=>{if(e===t){if(!0===a.strictMode&&!n)throw new r('Cannot declare a listener on the property/method in strict mode because another listener of the same function exists and "replaceSameListenerHandler" is not set to true!');o=!0}}),void 0===Object.getOwnPropertyDescriptor(e,l.setter)&&("property"===e.type?Object.defineProperty(e,l.setter,{enumerable:!0,configurable:!0,set:function(e){this[l.listeners].forEach(t=>{t(this[l.type],e,this[l.value])}),this[l.value]=e}}):"method"===e.type&&Object.defineProperty(e,l.setter,{enumerable:!0,configurable:!0,set:function(e){const t=e[0];this[l.listeners].forEach(t=>{t(this[l.type],e)});const r=this[l.value](t);e[1]=r}})),o&&n){let r=e[l.listeners].indexOf(t);return e[l.listeners][r]=t,e[l.listeners]}return!n&&o?e[l.listeners]:(e[l.listeners].push(t),e[l.listeners])}),CLIp.RemoveListener=((e,t)=>{if(p(e,!0),void 0===e)throw new TypeError('Parameter "objectlet" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "callback" (argument 2) is not defined.');if(Object.prototype.toString.call(e)!==Object.prototype.toString.call(new Object))throw new TypeError('Parameter "objectlet" (argument 1) is not a valid objectlet.');if("function"!=typeof t)throw new TypeError('Parameter "callback" (argument 2) is not a valid function.');if("property-container"===e[l.type]||"main-object"===e[l.type])throw new r('Cannot remove a listener to an objectlet with a type "property-container" or "main-object".');if("property"!==e[l.type]&&"method"!==e[l.type])throw new r("Cannot remove a listener to an objectlet without a valid or non-existing type.");if(!0!==e[l.allowListeners]&&!0===a.strictMode)throw new r("Cannot remove a listener to an objectlet not explicitly configured to do so in strict mode.");if("read-only"===e[l.propertyAccessibility]&&a.strictMode)throw new r('Cannot remove a listener to an objectlet with a property accessibility of "read-only" in strict mode.');if(!e[l.listeners])return e[l.listeners];let n=e[l.listeners].indexOf(t);if(-1===n&&a.strictMode)throw new r("Cannot remove the listener in strict mode because the listener doesn't exist!");return-1!==n||a.strictMode?(e[l].splice(n,1),e[l.listeners]):e[l.listeners]}),CLIp.CheckCommandLegality=(e=>(p(),new Promise((t,r)=>{const n=new u;n.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_");const o=n.Parse(e);let a="",i=!1,l=!1,s=!1;o.forEach(e=>{if("unknown_token"!==e.type)if("escaped_char"!==e.type||i)if("pointer"!==e.type||"pointer"!==a)if("pointer"!==e.type||"objectlet"===a||"type_declarator"===a)if("setter"!==e.type||"setter"!==a)if("setter"!==e.type||"objectlet"===a||"type_declarator"===a)if("argument_separator"!==e.type||"argument_separator"!==a)if("type_declarator"!==e.type||"pointer"!==a)if("type_declarator"!==a||"pointer"===e.type||"setter"===e.type||"argument_separator"===e.type)if("open_type_decl_failure"!==e.type)if("close_type_decl_failure"!==e.type)if("unclosed_string"!==e.type)if("unclosed_type_declarator"!==e.type)if("type_declarator"!==e.type||i)if("pointer"===e.type&&i)r(new SyntaxError(`Cannot currently use pointers on the right-hand side of the setter. Column number: ${e.column_numbers[0]}.`));else if("setter"===e.type&&i)r(new SyntaxError(`Cannot use a setter twice. Column number: ${e.column_numbers[0]}.`));else{if("string"!==e.type||i)if("string"===e.type&&i&&s)r(new SyntaxError(`Unexpected raw value after string (cannot combine two ajacent values). Column number: ${e.column_numbers[0]}.`));else if("objectlet"===e.type&&i&&l)r(new SyntaxError(`Unexpected string after raw value (cannot combine two ajacent values). Column number: ${e.column_numbers[0]}.`));else if("string"===e.type&&i)l=!0;else if("objectlet"===e.type&&i)s=!0;else if("type_declarator"===e.type){const t=e.value.split("");t.shift(),t.pop();let n=e.column_numbers[0]+1,o=!1,a=!1;if(t.forEach(e=>{if('"'===e&&(a=!a),":"!==e||o||a){if(":"===e&&o&&!a)return void r(new SyntaxError(`Unexpected token ":". Column number: ${n}.`))}else o=!0;++n}),a)return void r(new SyntaxError(`Unclosed string inside of type declarator. Column number: ${e.column_numbers[0]}.`));if(t.length<1)return void r(new SyntaxError(`Cannot have empty type declarator. Column number: ${e.column_numbers[0]}.`))}else"setter"===e.type&&(i=!0);else r(new SyntaxError(`Cannot use strings on the left-hand side of the setter. Column number: ${e.column_numbers[0]}.`));a=e.type}else r(new SyntaxError(`Cannot use type declarators on left-hand side of setter. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unclosed type declarator. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unclosed string. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected type declaration closing operator. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected type declaration opening operator. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected token "${e.value}", expecting an argument separator (or if it's a property - EOS (end of statement)) after type declarator. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected type declarator, expected objectlet (cannot use empty value). Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected argument separator, expected value. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected token before setter, expecting objectlet or type declarator but got ${a} instead. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected setter, expected value. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected token before pointer, expecting objectlet or type declarator but got ${a} instead. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected pointer, expecting objectlet. Column number: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unexpected escape character on the left-hand side of the setter. Column numbeR: ${e.column_numbers[0]}.`));else r(new SyntaxError(`Unknown token "${e.value}". Column number: ${e.column_numbers[0]}.`))}),"setter"!==o[o.length-1].type?"pointer"!==o[o.length-1].type?t(e):r(new SyntaxError(`Expected an objectlet after pointer but found EOS (end of statement) instead. Column number: ${o[o.length-1].column_numbers[0]}.`)):r(new SyntaxError(`Expected a value after setter but found EOS (end of statement) instead.Column number: ${o[o.length-1].column_numbers[0]}.`))}))),CLIp.GetRelevantCommands=((e,t,r,n,i=!0)=>{if(p(),void 0===e)throw new TypeError('Parameter "command" (argument 1) is not defined.');if("string"!=typeof e)throw new TypeError('Parameter "command" (argument 1) is not a valid string.');if(void 0!==t&&typeof t!=typeof!1)throw new TypeError('Parameter "properSyntaxEnforced" (argument 2) is set but is not of type "boolean".');if(void 0!==r&&"number"!=typeof r)throw new TypeError('Parameter "trimNum" (argument 3) is set but  not of type "number".');let c=!1;if("number"==typeof n&&(c=!0),e.length<1)return Promise.resolve(new Array(1,new Array(0)));e=e.toString();const y=e=>new Promise((t,r)=>{const p=[],y=new u;y.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_");const d=y.Parse(e);let m="";d.forEach(e=>{if("objectlet"===e.type)p.push(e.value);else if("unknown_token"===e.type)(":"!==e.value||":"===e.value&&"pointer"===m)&&t(new Array(0));else{if("escaped_char"===e.type)return void t(new Array(0));"setter"===e.type&&t(new Array(0))}m=e.type});const f=(e,t)=>{let r=0,o=0;if(typeof e!=typeof new Object)throw new TypeError('Parameter "obj" (argument 1) is not of type "'+typeof new Object+'".');return new Promise((a,s)=>{let p=[];const u=(e,t,s)=>{if("main-object"!==e[l.type]&&"property-container"!==e[l.type]&&"clip-help"!==e[l.type]&&!i)return p.push(t),void a(p);"main-object"!==e[l.type]&&"property-container"!==e[l.type]&&"clip-help"!==e[l.type]&&i&&p.push(t);for(let y in e)if(Object.prototype.toString.call(e[y])===Object.prototype.toString.call(new Object)&&0===r){if(c&&s.split("::").length>=n&&0===r)for(let t in e[y])r++;c&&s.split("::").length>=n?1!==n?u(e[y],t+"::"+y,s+"::"+y):p.push(t+"::"+y):u(e[y],t+"::"+y,s+"::"+y)}else{if(!i){if(y===l.type&&"string"==typeof e[y])continue;if(y===l.value)continue;if(y===l.allowedValues&&Object.prototype.toString.call(e[y])===Object.prototype.toString.call(new Array(0)))continue;if(y===l.propertyAccessibility&&"string"==typeof e[y])continue;if(y===l.allowListeners&&typeof e[y]==typeof!0)continue;if(y===l.listeners&&Object.prototype.toString.call(e[y])===Object.prototype.toString.call([]))continue;if(y===l.setValue&&typeof e[y]==typeof Function)continue}c&&s.split("::").length>n&&r>0?(p.push(t+"::"+y),++o>=r&&a(p)):(p.push(t+"::"+y),a(p))}};u(e,t,"")})};let h=o;p.forEach((r,n)=>{if(n>=p.length-1)if(void 0===h[r])if(a.strictCommandMode){let e=new RegExp("^"+s(r)),n=[];for(let t in h){if(!i&&(t===l.type||t===l.allowedValues||t===l.propertyAccessibility||t===l.allowListeners||t===l.listeners||t===l.setter||t===l.value)&&Object.prototype.toString.call(h[t])!==Object.prototype.toString.call(new Object))continue;e.test(t)&&n.push(t)}let o=[];n.forEach(e=>{for(let t in l)if(l[t]===e&&i)return void o.push(p.map(e=>e).splice(0,p.length-1).join("::")+"::"+e);p.length<2?f(h[e],p.map(e=>e).splice(0,p.length-1).join("::")+e).then(e=>{e.forEach(e=>{o.push(e)})}):f(h[e],p.map(e=>e).splice(0,p.length-1).join("::")+"::"+e).then(e=>{e.forEach(e=>{o.push(e)})})}),t(o)}else{let e=new RegExp("^"+s(r),"i"),n=[];for(let t in h){if(!i&&(t===l.type||t===l.allowedValues||t===l.propertyAccessibility||t===l.allowListeners||t===l.listeners||t===l.setter||t===l.value)&&Object.prototype.toString.call(h[t])!==Object.prototype.toString.call(new Object))continue;e.test(t)&&n.push(t)}let o=[];n.forEach(e=>{for(let t in l)if(l[t]===e&&i)return void o.push(p.map(e=>e).splice(0,p.length-1).join("::")+"::"+e);p.length<2?f(h[e],p.map(e=>e).splice(0,p.length-1).join("::")+e).then(e=>{e.forEach(e=>{o.push(e)})}):f(h[e],p.map(e=>e).splice(0,p.length-1).join("::")+"::"+e).then(e=>{e.forEach(e=>{o.push(e)})})}),t(o)}else{if(typeof h[r]!=typeof new Object)return void t(new Array(0));f(h[r],p.join("::")).then(n=>{1===n.length&&h[r][l.value]?t([e]):t(n)})}else{let e=!1;for(let t in h)t.toLowerCase()===r.toLowerCase()&&(h=h[t],p[n]=t,e=!0);e||t(new Array(0))}})});return t?new Promise((t,n)=>{CLIp.CheckCommandLegality(e).then(e=>{y(e).then(e=>{Array.isArray(e)?r?(e.splice(r),t([1,e])):t([1,e]):t([0,e])})}).catch(e=>{n([0,e])})}):new Promise((t,n)=>y(e).then(e=>{Array.isArray(e)?r?(e.splice(r),t([1,e])):t([1,e]):t([0,t])}).catch(e=>{n([0,e])}))}),CLIp.ParseInput=(r=>{if(p(),void 0===r)throw new TypeError('Parameter "command" (argument 1) is not defined.');if(r.length<1)return"";return new Promise((n,s)=>{CLIp.CheckCommandLegality(r).then(e=>(e=>new Promise((r,n)=>{const i=[],l=[];let s=!1,p=0;const c=new u;if(c.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_"),c.Parse(e).forEach(e=>{"objectlet"!==e.type||s?"setter"===e.type&&(s=!0,p=e.column_numbers[0]):(i.push(e.value),l.push(e.column_numbers[0]))}),!s&&"writeOnly"===a.executionMode.value)return void n(new t(`Cannot omit setter operator in  "write-only" mode. Column number: ${p}.`));if(s&&"readOnly"===a.executionMode.value)return void n(new t(`Cannot use setter operator in "read-only" mode. Column number: ${p}.`));let y=o;i.forEach((e,r)=>{if(!1===a.strictCommandMode)for(let t in y)t.toLowerCase()===e.toLowerCase()&&(i[r]=t);void 0!==y[i[r]]?y=y[i[r]]:n(new t(`An undefined objectlet was found: "${e}". Column number: ${l[r]}.`))}),r([e,y,i[i.length-1]])}))(e)).then(([e,r,n])=>((e,r,n)=>new Promise((o,a)=>{const s=new u;s.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_");const p=s.Parse(e,!1,!0),c=p.length>0;let y=!1;"main-object"!==r[l.type]&&"property-container"!==r[l.type]||!c||a(new t("Cannot change the value of or execute a main object/property container."));let d=!1;for(let e in l)l[e]===n&&(d=!0);if(void 0!==r[l.type]||d)if(y="method"!==r[l.type]){let s="",u="string";const d=r[l.allowedTypes]&&Array.isArray(r[l.allowedTypes])?r[l.allowedTypes].filter(e=>e.default_type):[];d.length>0&&(u=d[0].default_type),p.forEach(e=>{if("objectlet"===e.type||"string"===e.type||"escaped_char"===e.type)s+=e.value;else if("argument_separator"===e.type)a(new t(`Cannot use argument separators on a property. Column number: ${e.column_numbers[0]}.`));else if("type_declarator"===e.type){let r="",n="",o=!0,l=!1,s=e.value.split("");s.shift(),s.pop(),s.forEach(e=>{'"'===e?l=!l:o?":"!==e||l?r+=e:o=!1:o||(n+=e)}),"type"!==r&&a(new t(`Unknown type declarator command "${r}". Column number: ${e.column_numbers[0]}.`)),i.filter(e=>e===n).length<1&&a(new t(`Unsupported type "${n}". Column number: ${e.column_numbers[0]}.`)),u=n}}),o([e,r,s,u,y,!c,n])}else{const l=new Array(0),s=new Array(0);let u=!1;if(p.forEach(e=>{if("objectlet"!==e.type&&"string"!==e.type||u)if("objectlet"!==e.type&&"string"!==e.type||!u){if("escaped_char"===e.type)l[l.length-1]+=e.value,u=!0;else if("argument_separator"===e.type)u=!1;else if("type_declarator"===e.type){let r="",n="",o=!0,l=!1,p=e.value.split("");p.shift(),p.pop(),p.forEach(e=>{'"'===e?l=!l:o?":"!==e||l?r+=e:o=!1:o||(n+=e)}),"type"!==r&&a(new t(`Unknown type declarator command "${r}". Column number: ${e.column_numbers[0]}.`)),i.filter(e=>e===n).length<1&&a(new t(`Unsupported type "${n}". Column number: ${e.column_numbers[0]}.`)),s.push(n)}}else l[l.length-1]+=e.value,u=!1;else l.push(e.value)}),s.length<1)for(let e=0,t=l.length;e<t;++e)s.push("string");o([e,r,l,s,y,!c,n])}else a(new t(`Target objectlet ${n}'s type cannot be determined ("property","method", "property-container" or "main-object") meaning that it is not changable (Main objects and property-containers are not changable).`))}))(e,r,n)).then(([r,n,o,i,s,p,c])=>((r,n,o,i,s,p,c)=>new Promise((r,u)=>{if(!n[l.locked]||p)try{const t=()=>{if(i)if("infer"===i)if(n[l.allowedValues].length>1){let t=0;n[l.allowedValues].filter((e,r)=>{e[0].toLowerCase()===o.toLowerCase()&&(t=r)});const r=n[l.allowedValues][t][1];if(r.forEach(e=>{"null"===e?o=null:"undefined"===e?o=void 0:"NaN"===e?o=NaN:Number.isNaN(Number(e))||""===e||(o=Number(o))}),"string"==typeof o&&!r.includes("string"))throw u(new e("Cannot convert value's type to an allowed type -  the type of the value does not match any of the allowed types for the allowed value.")),""}else n[l.allowedTypes].length>1?n[l.allowedTypes].forEach(e=>{"null"===e?o=null:"undefined"===e?o=void 0:"NaN"===e?o=NaN:Number.isNaN(Number(e))||""===e||(o=Number(o))}):"null"===o?o=null:"undefined"===o?o=void 0:"NaN"===o?o=NaN:Number.isNaN(Number(o))||""===o||(o=Number(o));else if("null"===i)o=null;else if("undefined"===i)o=void 0;else if("NaN"===i)o=NaN;else if("number"===i){if(Number.isNaN(Number(o)))throw u(new e(`Attempt to convert a "${o}" to a number failed. "${o}" is not a valid number.`)),"";o=Number(o)}else"string"===i&&(o=o.toString())};let y=!1;for(let e in l)l[e]===c&&(y=!0);let d=n[l.type];if(d="method"===d?"Executable Command":"property"===d?n[l.propertyAccessibility]&&"read-only"===n[l.propertyAccessibility]?"Read-Only Value":"Changable Value":"main-object"===d?"Main Property Container":"property-container"===d?"Property Container":"clip-help"===d?"Official CLIp help commands":"Unknown",p&&!y)r("Property Container"===d||"Main Property Container"===d||"Official CLIp help commands"===d?[d,"object",JSON.stringify(n)]:[d,typeof n[l.value],n[l.value]]);else if(y){if(!p)throw new e("Cannot change values of metadata.");r(["Objectlet Metadata",typeof n,n])}else{if(n[l.allowedTypes]&&n[l.allowedTypes].length>0){const t=n[l.allowedTypes];if(t.filter(e=>e===i).length<1&&!t.includes("all")){const t=n[l.allowedTypes];return t.forEach((e,r)=>{e.default_type&&t.splice(r,1)}),void u(new e(`Cannot set property's value to "${o}" with type "${i}" because it violates the allowed types for the property ("${t}").`))}}if(n[l.allowedValues]&&n[l.allowedValues].length>0){if(n[l.allowedValues].filter(e=>!0===a.strictCommandMode?e[0]===o:e[0].toLowerCase()===o.toLowerCase()).length<1){const t=n[l.allowedValues].reduce((e,t)=>""===e?t[0]:e+`, ${t[0]}`,"");return void u(new e(`Cannot set property's value to "${o}" because it violates the allowed values for the property ("${t}").`))}let t=0;n[l.allowedValues].filter((e,r)=>{e[0].toLowerCase()===o.toLowerCase()&&(t=r)});const r=n[l.allowedValues][t][1];if(r.filter(e=>e===i).length<1&&!r.includes("all")){const t=r.join(", ");return void u(new e(`Cannot set property's value to "${o}" with type "${i}" because it violates the allowed types for the specific value ("${t}").`))}}let p;if(void 0!==Object.getOwnPropertyDescriptor(n,l.setter))if(s){if(n[l.propertyAccessibility]&&"read-only"===n[l.propertyAccessibility])return void u(new e("Cannot change the property's value because it is read-only."));t(),n[l.setter]=o,p=n[l.value]}else{const e=[o];n[l.setter]=e,p=e[1]}else if(s){if(n[l.propertyAccessibility]&&"read-only"===n[l.propertyAccessibility])return void u(new e("Cannot change the property because it is read-only."));t(),p=n[l.value]=o}else{const t=t=>{i[t]&&("infer"===i[t]?"null"===o[t]?o[t]=null:"undefined"===o[t]?o[t]=void 0:"NaN"===o?o[t]=NaN:Number.isNaN(Number(o))||(o[t]=Number(o)):"null"===i[t]?o[t]=null:"undefined"===i[t]?o[t]=void 0:"NaN"===i[t]?o[t]=NaN:"number"===i[t]?Number.isNaN(Number(o[t]))?u(new e(`Attempt to convert a "${o[t]}" to a number failed. "${o[t]}" is not a valid number.`)):o[t]=Number(o[t]):"string"===i[t]&&(o[t]=o[t].toString()))};o.length>1?o.forEach((e,r)=>{t(r)}):i.length>1&&i.forEach((e,r)=>{t(r)}),p=n[l.value](...o)}r([d,typeof p,p])}}catch(e){u(e)}else u(new t("Cannot change the value of a locked objectlet."))}))(0,n,o,i,s,p,c)).then(e=>{n(e)}).catch(e=>{s(e)})})})})();
